<%
var enable = theme.post.math.enable;

if (enable) {
  if (is_post()) {
    enable = !theme.post.math.specific || (theme.post.math.specific && page.math);
  } else if (is_page()) {
    enable = page.math;
  } else {
    enable = false;
  }
}
%>

<% if (enable) { %>
<% var engine = theme.post.math.engine; %>

<% if(engine === 'mathjax') { %>
<!-- MathJax -->
<script>
  MathJax = {
    startup: {
      requireMap: {
        AMSmath: 'ams',
        AMSsymbols: 'ams',
        AMScd: 'amsCd',
        HTML: 'html',
        noErrors: 'noerrors',
        noUndefined: 'noundefined'
      },
      ready: function () {
        //
        //  Replace the require command map with a new one that checks for
        //    renamed extensions and converts them to the new names.
        //
        var CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
        var requireMap = MathJax.config.startup.requireMap;
        var RequireLoad = MathJax._.input.tex.require.RequireConfiguration.RequireLoad;
        var RequireMethods = {
          Require: function (parser, name) {
            var required = parser.GetArgument(name);
            if (required.match(/[^_a-zA-Z0-9]/) || required === '') {
              throw new TexError('BadPackageName', 'Argument for %1 is not a valid package name', name);
            }
            if (requireMap.hasOwnProperty(required)) {
              required = requireMap[required];
            }
            RequireLoad(parser, required);
          }
        };
        new CommandMap('require', { require: 'Require' }, RequireMethods);

        return MathJax.startup.defaultReady();
      }
    },
    tex: {
      autoload: {
        color: [],          // don't autoload the color extension
        colorV2: ['color'], // do autoload the colorV2 extension
      },
      inlineMath: [['$', '$'], ['\\(', '\\)']]
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
            const display = !!node.type.match(/; *mode=display/);
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
            const text = document.createTextNode('');
            node.parentNode.replaceChild(text, node);
            math.start = { node: text, delim: '', n: 0 };
            math.end = { node: text, delim: '', n: 0 };
            doc.math.push(math);
          });
        }, '', false],
        insertedScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            let target = node.parentNode;
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax');
            }
          });
        }, '', false]
      }
    }
  };
</script>

<%- js_ex(theme.static_prefix.mathjax, "tex-svg.js") %>

<% } else if (engine === 'katex') { %>
<!-- KaTeX -->
<%- css_ex(theme.static_prefix.katex, "katex.min.css") %>
<% } %>
<% } %>